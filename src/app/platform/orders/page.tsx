'use client';

import { useState, useRef, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Order, StatusConfig, StatsData, Tab } from './types';
import DashboardTab from './components/DashboardTab';
import OrderRegistrationTab from './components/OrderRegistrationTab';
import MobileRegistrationTab from './components/MobileRegistrationTab';
import SettlementTab from './components/SettlementTab';
import OptionMappingTab from './components/OptionMappingTab';
import UploadModal from './modals/UploadModal';
import OrderDetailModal from './modals/OrderDetailModal';
import ValidationErrorModal from './modals/ValidationErrorModal';
import OptionValidationModal from './modals/OptionValidationModal';
import MappingResultModal from './modals/MappingResultModal';
import { ThemeToggle } from '@/components/ui/ThemeToggle';
import * as XLSX from 'xlsx';
import { validateRequiredColumns } from './utils/validation';
import toast, { Toaster } from 'react-hot-toast';
import { getCurrentTimeUTC } from '@/lib/date';
import { applyOptionMapping } from './utils/applyOptionMapping';

export default function OrdersPage() {
  const [activeTab, setActiveTab] = useState<Tab>('ÎåÄÏãúÎ≥¥Îìú');
  const router = useRouter();
  const [userId, setUserId] = useState<string>('');
  const [userEmail, setUserEmail] = useState<string>('');
  const [orders, setOrders] = useState<Order[]>([]);

  const [filterStatus, setFilterStatus] = useState<'all' | Order['status']>('registered');
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [selectedOrders, setSelectedOrders] = useState<number[]>([]);
  const [showUploadModal, setShowUploadModal] = useState<boolean>(false);
  const [showDetailModal, setShowDetailModal] = useState<boolean>(false);
  const [selectedOrder, setSelectedOrder] = useState<Order | null>(null);
  const [dragActive, setDragActive] = useState<boolean>(false);
  const [isMobile, setIsMobile] = useState<boolean>(false);
  const [sidebarOpen, setSidebarOpen] = useState<boolean>(false);
  const [startDate, setStartDate] = useState<Date | null>(new Date());
  const [endDate, setEndDate] = useState<Date | null>(new Date());
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  const [showValidationModal, setShowValidationModal] = useState<boolean>(false);
  const [showOptionValidationModal, setShowOptionValidationModal] = useState<boolean>(false);
  const [uploadedOrders, setUploadedOrders] = useState<any[]>([]);
  const [optionProductsMap, setOptionProductsMap] = useState<Map<string, any>>(new Map());
  const [showMappingResultModal, setShowMappingResultModal] = useState<boolean>(false);
  const [mappingResults, setMappingResults] = useState<any[]>([]);
  const [mappingStats, setMappingStats] = useState({ total: 0, mapped: 0 });

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 768);
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  useEffect(() => {
    const supabase = createClient();
    supabase.auth.getUser().then(({ data: { user } }) => {
      console.log('üîç ÌòÑÏû¨ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê:', user);
      if (user) {
        setUserId(user.id);
        if (user.email) {
          setUserEmail(user.email);
          console.log('‚úÖ ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï - ID:', user.id, 'Email:', user.email);
        }
      } else {
        console.log('‚ùå Î°úÍ∑∏Ïù∏ÎêòÏßÄ ÏïäÏùå');
      }
    });

    // integrated_ordersÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞
    fetchOrders();
  }, []);

  const fetchOrders = async () => {
    const supabase = createClient();
    const { data: { user } } = await supabase.auth.getUser();

    console.log('üîç fetchOrders Ìò∏Ï∂úÎê®');
    console.log('üë§ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê:', user);

    if (!user) {
      console.log('‚ùå ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÎêòÏßÄ ÏïäÏùå');
      return;
    }

    console.log('üìã ÏÇ¨Ïö©Ïûê IDÎ°ú Ï£ºÎ¨∏ Ï°∞Ìöå Ï§ë:', user.id);

    // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÖÄÎü¨Ïùò Ï£ºÎ¨∏Îßå Ï°∞Ìöå
    const { data, error } = await supabase
      .from('integrated_orders')
      .select('*')
      .eq('seller_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('‚ùå Ï£ºÎ¨∏ Ï°∞Ìöå Ïò§Î•ò:', error);
      return;
    }

    console.log('‚úÖ Ï°∞ÌöåÎêú Ï£ºÎ¨∏ Í∞úÏàò:', data?.length || 0);
    console.log('üì¶ Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞:', data);

    // shipping_statusÎ•º Order statusÎ°ú Îß§Ìïë
    const mapShippingStatus = (shippingStatus: string | null): Order['status'] => {
      if (!shippingStatus) return 'registered';

      const statusMap: Record<string, Order['status']> = {
        'Î∞úÏ£ºÏÑúÎì±Î°ù': 'registered',
        'Î∞úÏ£ºÏÑúÌôïÏ†ï': 'confirmed',
        'Í≤∞Ï†úÏôÑÎ£å': 'confirmed',
        'ÏÉÅÌíàÏ§ÄÎπÑÏ§ë': 'preparing',
        'Î∞∞ÏÜ°Ï§ë': 'shipped',
        'Î∞∞ÏÜ°ÏôÑÎ£å': 'shipped',
        'Î∞úÏÜ°ÏôÑÎ£å': 'shipped',
        'Ï∑®ÏÜåÏöîÏ≤≠': 'cancelRequested',
        'Ï∑®ÏÜåÏôÑÎ£å': 'cancelled',
        'ÌôòÎ∂àÏôÑÎ£å': 'refunded',
        'refunded': 'refunded'
      };

      return statusMap[shippingStatus] || 'registered';
    };

    // integrated_orders Îç∞Ïù¥ÌÑ∞Î•º Order ÌÉÄÏûÖÏúºÎ°ú Î≥ÄÌôò
    const convertedOrders: Order[] = (data || []).map((order: any, index: number) => ({
      id: order.id,
      orderNo: order.order_number || order.order_no || `TEMP${order.id}`, // ÏãúÏä§ÌÖú Î∞úÏ£ºÎ≤àÌò∏
      orderNumber: order.seller_order_number, // ÏÖÄÎü¨ Ï£ºÎ¨∏Î≤àÌò∏
      products: order.option_name,
      amount: 0,
      quantity: parseInt(order.quantity) || 0,
      status: mapShippingStatus(order.shipping_status),
      date: order.created_at,
      registeredAt: order.created_at,
      confirmedAt: order.confirmed_at, // Î∞úÏ£ºÌôïÏ†ïÏùºÏãú
      shippedDate: order.shipped_date, // Î∞úÏÜ°Ïùº
      courier: order.courier_company, // ÌÉùÎ∞∞ÏÇ¨
      trackingNo: order.tracking_number, // ÏÜ°Ïû•Î≤àÌò∏
      cancelRequestedAt: order.cancel_requested_at,
      cancelledAt: order.canceled_at,
      cancelReason: order.cancel_reason,
      orderer: order.buyer_name,
      ordererPhone: order.buyer_phone,
      recipient: order.recipient_name,
      recipientPhone: order.recipient_phone,
      address: order.recipient_address,
      deliveryMessage: order.delivery_message,
      optionName: order.option_name,
      optionCode: order.option_code || '',
      specialRequest: order.special_request,
      unitPrice: order.seller_supply_price ? parseFloat(order.seller_supply_price) : undefined,
      supplyPrice: order.settlement_amount ? parseFloat(order.settlement_amount) : undefined,
      refundAmount: order.settlement_amount ? parseFloat(order.settlement_amount) : undefined, // ÌôòÎ∂àÏï° (Ï†ïÏÇ∞Í∏àÏï°Í≥º ÎèôÏùº)
      refundedAt: order.refund_processed_at, // ÌôòÎ∂àÏùº
      marketName: order.market_name || 'ÎØ∏ÏßÄÏ†ï' // ÎßàÏºìÎ™Ö
    }));

    console.log('üîÑ Î≥ÄÌôòÎêú Ï£ºÎ¨∏ Îç∞Ïù¥ÌÑ∞:', convertedOrders);
    setOrders(convertedOrders);
  };

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑúÎßå localStorageÏóêÏÑú ÌÉ≠ Î∂àÎü¨Ïò§Í∏∞
  useEffect(() => {
    const savedTab = localStorage.getItem('ordersActiveTab');
    if (savedTab) {
      setActiveTab(savedTab as Tab);
    } else {
      // Ï†ÄÏû•Îêú ÌÉ≠Ïù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú 'ÎåÄÏãúÎ≥¥Îìú' ÏÑ§Ï†ï
      setActiveTab('ÎåÄÏãúÎ≥¥Îìú');
      localStorage.setItem('ordersActiveTab', 'ÎåÄÏãúÎ≥¥Îìú');
    }
  }, []);

  // ÌÉ≠ Î≥ÄÍ≤Ω Ïãú localStorageÏóê Ï†ÄÏû•
  const handleTabChange = (tab: Tab) => {
    setActiveTab(tab);
    localStorage.setItem('ordersActiveTab', tab);
    // Î™®Î∞îÏùºÏóêÏÑú ÌÉ≠ Î≥ÄÍ≤Ω Ïãú ÏÇ¨Ïù¥ÎìúÎ∞î Îã´Í∏∞
    if (isMobile) {
      setSidebarOpen(false);
    }
  };

  const statusConfig: Record<Order['status'] | 'refunded', StatusConfig> = {
    registered: { label: 'Î∞úÏ£ºÏÑúÎì±Î°ù', color: '#2563eb', bg: '#dbeafe' },
    confirmed: { label: 'Î∞úÏ£ºÏÑúÌôïÏ†ï', color: '#7c3aed', bg: '#ede9fe' },
    preparing: { label: 'ÏÉÅÌíàÏ§ÄÎπÑÏ§ë', color: '#f59e0b', bg: '#fef3c7' },
    shipped: { label: 'Î∞úÏÜ°ÏôÑÎ£å', color: '#10b981', bg: '#d1fae5' },
    cancelRequested: { label: 'Ï∑®ÏÜåÏöîÏ≤≠', color: '#ef4444', bg: '#fee2e2' },
    cancelled: { label: 'Ï∑®ÏÜåÏôÑÎ£å', color: '#6b7280', bg: '#f3f4f6' },
    refunded: { label: 'ÌôòÎ∂àÏôÑÎ£å', color: '#10b981', bg: '#d1fae5' }
  };

  const statsData: StatsData[] = [
    { status: 'registered', count: orders.filter(o => o.status === 'registered').length, bgGradient: 'linear-gradient(135deg, #2563eb 0%, #60a5fa 100%)' },
    { status: 'confirmed', count: orders.filter(o => o.status === 'confirmed').length, bgGradient: 'linear-gradient(135deg, #7c3aed 0%, #a78bfa 100%)' },
    { status: 'preparing', count: orders.filter(o => o.status === 'preparing').length, bgGradient: 'linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%)' },
    { status: 'shipped', count: orders.filter(o => o.status === 'shipped').length, bgGradient: 'linear-gradient(135deg, #10b981 0%, #34d399 100%)' },
    { status: 'cancelRequested', count: orders.filter(o => o.status === 'cancelRequested').length, bgGradient: 'linear-gradient(135deg, #ef4444 0%, #f87171 100%)' },
    { status: 'cancelled', count: orders.filter(o => o.status === 'cancelled').length, bgGradient: 'linear-gradient(135deg, #6b7280 0%, #9ca3af 100%)' },
    { status: 'refunded', count: orders.filter(o => o.status === 'refunded').length, bgGradient: 'linear-gradient(135deg, #10b981 0%, #34d399 100%)' }
  ];

  const handleDrag = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleFiles(e.dataTransfer.files);
    }
  };

  const handleFiles = async (files: FileList) => {
    const file = files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const data = e.target?.result;
        const workbook = XLSX.read(data, { type: 'binary', WTF: true });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);


        console.log('ÏóÖÎ°úÎìúÎêú Îç∞Ïù¥ÌÑ∞:', jsonData);

        // ÌïÑÏàò ÏπºÎüº Í≤ÄÏ¶ù
        const errors = validateRequiredColumns(jsonData);
        if (errors.length > 0) {
          setValidationErrors(errors);
          setShowValidationModal(true);
          setShowUploadModal(false);
          return;
        }

        // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        const supabase = createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
          toast.error('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.', {
            position: 'top-center',
            duration: 3000
          });
          return;
        }

        // UTC ÏãúÍ∞Ñ ÏÉùÏÑ±
        const utcTime = getCurrentTimeUTC();

        // Î™®Îì† ÏòµÏÖòÎ™ÖÍ≥º ÏòµÏÖòÏΩîÎìú ÏàòÏßë (Ï§ëÎ≥µ Ï†úÍ±∞)
        const uniqueOptionNames = [...new Set(jsonData.map((row: any) => String(row['ÏòµÏÖòÎ™Ö'] || '')).filter(Boolean))];
        const uniqueOptionCodes = [...new Set(jsonData.map((row: any) => String(row['ÏòµÏÖòÏΩîÎìú'] || '')).filter(Boolean))];

        console.log('üìã ÏàòÏßëÎêú ÏòµÏÖòÎ™Ö:', uniqueOptionNames);
        console.log('üìã ÏàòÏßëÎêú ÏòµÏÖòÏΩîÎìú:', uniqueOptionCodes);

        // option_productsÏóêÏÑú Í≥µÍ∏âÎã®Í∞Ä Ï°∞Ìöå
        let optionProducts: any[] = [];

        // ÏòµÏÖòÎ™ÖÏúºÎ°ú Ï°∞Ìöå
        if (uniqueOptionNames.length > 0) {
          const { data: nameData, error: nameError } = await supabase
            .from('option_products')
            .select('option_name, option_code, seller_supply_price')
            .in('option_name', uniqueOptionNames);

          if (nameError) {
            console.error('‚ùå ÏòµÏÖòÎ™Ö Ï°∞Ìöå Ïò§Î•ò:', nameError);
          } else {
            console.log('‚úÖ ÏòµÏÖòÎ™ÖÏúºÎ°ú Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞:', nameData);
            if (nameData) {
              optionProducts = [...optionProducts, ...nameData];
            }
          }
        }

        // ÏòµÏÖòÏΩîÎìúÎ°ú Ï°∞Ìöå
        if (uniqueOptionCodes.length > 0) {
          const { data: codeData, error: codeError } = await supabase
            .from('option_products')
            .select('option_name, option_code, seller_supply_price')
            .in('option_code', uniqueOptionCodes);

          if (codeError) {
            console.error('‚ùå ÏòµÏÖòÏΩîÎìú Ï°∞Ìöå Ïò§Î•ò:', codeError);
          } else {
            console.log('‚úÖ ÏòµÏÖòÏΩîÎìúÎ°ú Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞:', codeData);
            if (codeData) {
              optionProducts = [...optionProducts, ...codeData];
            }
          }
        }

        console.log('üí∞ ÏµúÏ¢Ö Ï°∞ÌöåÎêú ÏòµÏÖòÏÉÅÌíà:', optionProducts);

        // ÏòµÏÖòÏÉÅÌíà Map Ï†ÄÏû• (ÏòµÏÖòÎ™Ö ÏÜåÎ¨∏Ïûê ÌÇ§Î°ú Ï†ÄÏû•)
        const productMap = new Map<string, any>();
        optionProducts.forEach((product: any) => {
          if (product.option_name) {
            const key = product.option_name.trim().toLowerCase();
            productMap.set(key, product);
          }
        });
        setOptionProductsMap(productMap);

        // Ï£ºÎ¨∏ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
        let ordersForValidation = jsonData.map((row: any, index: number) => ({
          index,
          orderNumber: String(row['Ï£ºÎ¨∏Î≤àÌò∏'] || ''),
          orderer: String(row['Ï£ºÎ¨∏Ïûê'] || ''),
          ordererPhone: String(row['Ï£ºÎ¨∏ÏûêÏ†ÑÌôîÎ≤àÌò∏'] || ''),
          recipient: String(row['ÏàòÎ†πÏù∏'] || ''),
          recipientPhone: String(row['ÏàòÎ†πÏù∏Ï†ÑÌôîÎ≤àÌò∏'] || ''),
          address: String(row['Ï£ºÏÜå'] || ''),
          deliveryMessage: String(row['Î∞∞ÏÜ°Î©îÏÑ∏ÏßÄ'] || ''),
          optionName: String(row['ÏòµÏÖòÎ™Ö'] || ''),
          optionCode: String(row['ÏòµÏÖòÏΩîÎìú'] || ''),
          quantity: String(row['ÏàòÎüâ'] || '1'),
          specialRequest: String(row['ÌäπÏù¥/ÏöîÏ≤≠ÏÇ¨Ìï≠'] || ''),
          // DB Ï†ÄÏû•Ïö© Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ (Í≤ÄÏ¶ù ÌõÑ ÏÇ¨Ïö©)
          _metadata: {
            sheet_date: utcTime.split('T')[0],
            seller_id: user.id,
            created_by: user.id,
            market_name: 'ÌîåÎû´Ìèº',
            payment_date: utcTime.split('T')[0],
            shipping_status: 'Î∞úÏ£ºÏÑúÎì±Î°ù'
          }
        }));

        // 1Îã®Í≥Ñ: ÏòµÏÖòÎ™Ö Îß§Ìïë Ï†ÅÏö©
        const { orders: mappedOrders, mappingResults: results, totalOrders, mappedOrders: mappedCount } =
          await applyOptionMapping(ordersForValidation, user.id);

        ordersForValidation = mappedOrders;

        // Îß§Ìïë ÌõÑ Î≥ÄÌôòÎêú ÏòµÏÖòÎ™ÖÏúºÎ°ú option_products Îã§Ïãú Ï°∞Ìöå
        if (results.length > 0) {
          const mappedOptionNames = [...new Set(ordersForValidation.map(order => String(order.optionName || '')).filter(Boolean))];

          if (mappedOptionNames.length > 0) {
            const { data: mappedNameData, error: mappedNameError } = await supabase
              .from('option_products')
              .select('option_name, option_code, seller_supply_price')
              .in('option_name', mappedOptionNames);

            if (mappedNameError) {
              console.error('‚ùå Îß§ÌïëÎêú ÏòµÏÖòÎ™Ö Ï°∞Ìöå Ïò§Î•ò:', mappedNameError);
            } else if (mappedNameData) {
              console.log('‚úÖ Îß§ÌïëÎêú ÏòµÏÖòÎ™ÖÏúºÎ°ú Ï°∞ÌöåÎêú Îç∞Ïù¥ÌÑ∞:', mappedNameData);
              // Í∏∞Ï°¥ optionProductsÏóê Ï∂îÍ∞Ä
              optionProducts = [...optionProducts, ...mappedNameData];

              // productMap Îã§Ïãú ÏÉùÏÑ±
              const updatedProductMap = new Map<string, any>();
              optionProducts.forEach((product: any) => {
                if (product.option_name) {
                  const key = product.option_name.trim().toLowerCase();
                  updatedProductMap.set(key, product);
                }
              });
              setOptionProductsMap(updatedProductMap);
            }
          }
        }

        // 2Îã®Í≥Ñ: Îß§Ìïë Í≤∞Í≥ºÍ∞Ä ÏûàÏúºÎ©¥ Í≤∞Í≥º Î™®Îã¨ ÌëúÏãú
        if (results.length > 0) {
          setMappingResults(results);
          setMappingStats({ total: totalOrders, mapped: mappedCount });
          setUploadedOrders(ordersForValidation);
          setShowUploadModal(false);
          setShowMappingResultModal(true);
        } else {
          // Îß§Ìïë Í≤∞Í≥ºÍ∞Ä ÏóÜÏúºÎ©¥ Î∞îÎ°ú Í≤ÄÏ¶ù Î™®Îã¨Î°ú
          setUploadedOrders(ordersForValidation);
          setShowUploadModal(false);
          setShowOptionValidationModal(true);
        }

      } catch (error) {
        console.error('ÏóëÏÖÄ ÌååÏùº ÏùΩÍ∏∞ Ïò§Î•ò:', error);
        toast.error('ÏóëÏÖÄ ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÏñëÏãùÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.', {
          position: 'top-center',
          duration: 3000
        });
      }
    };
    reader.readAsBinaryString(file);
  };

  const handleSaveValidatedOrders = async (validatedOrders: any[]) => {
    try {
      const supabase = createClient();
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        toast.error('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.', {
          position: 'top-center',
          duration: 3000
        });
        return;
      }

      // Í≤ÄÏ¶ùÎêú Ï£ºÎ¨∏ Îç∞Ïù¥ÌÑ∞Î•º DB ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
      const ordersToInsert = validatedOrders.map((order) => {
        const quantity = parseInt(order.quantity) || 1;
        const unitPrice = order.unitPrice || 0;
        const supplyPrice = order.supplyPrice || (unitPrice * quantity);

        return {
          market_name: order._metadata.market_name,
          seller_order_number: order.orderNumber, // ÏÖÄÎü¨Ïùò Ï£ºÎ¨∏Î≤àÌò∏
          buyer_name: order.orderer,
          buyer_phone: order.ordererPhone,
          recipient_name: order.recipient,
          recipient_phone: order.recipientPhone,
          recipient_address: order.address,
          delivery_message: order.deliveryMessage,
          option_name: order.optionName,
          option_code: order.optionCode,
          quantity: String(quantity),
          special_request: order.specialRequest,
          seller_supply_price: unitPrice,
          settlement_amount: supplyPrice,
          sheet_date: order._metadata.sheet_date,
          payment_date: order._metadata.payment_date,
          shipping_status: order._metadata.shipping_status,
          seller_id: order._metadata.seller_id,
          created_by: order._metadata.created_by,
          created_at: getCurrentTimeUTC(),
          is_deleted: false
        };
      });

      console.log('üíæ DBÏóê Ï†ÄÏû•Ìï† Ï£ºÎ¨∏ Îç∞Ïù¥ÌÑ∞:', ordersToInsert);

      // APIÎ•º ÌÜµÌï¥ Ï£ºÎ¨∏ ÏùºÍ¥Ñ Ï†ÄÏû• (ÏòµÏÖò ÏÉÅÌíà Ï†ïÎ≥¥ ÏûêÎèô Îß§Ìïë)
      const response = await fetch('/api/platform-orders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ orders: ordersToInsert }),
      });

      const result = await response.json();

      if (!result.success) {
        console.error('‚ùå Ï£ºÎ¨∏ Ï†ÄÏû• Ïã§Ìå®:', result.error);
        toast.error(`Ï£ºÎ¨∏ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${result.error}`, {
          position: 'top-center',
          duration: 3000
        });
        return;
      }

      console.log('‚úÖ Ï£ºÎ¨∏ Ï†ÄÏû• ÏÑ±Í≥µ:', result.data);
      toast.success(`${result.count}Í±¥Ïùò Ï£ºÎ¨∏Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Îì±Î°ùÎêòÏóàÏäµÎãàÎã§.`, {
        position: 'top-center',
        duration: 3000
      });

      // Î™®Îã¨ Îã´Í∏∞ Î∞è ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setShowOptionValidationModal(false);
      setUploadedOrders([]);
      setOptionProductsMap(new Map());

      // Ï£ºÎ¨∏ Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
      await fetchOrders();

    } catch (error) {
      console.error('‚ùå Ï£ºÎ¨∏ Ï†ÄÏû• Ï§ë Ïò§Î•ò:', error);
      toast.error('Ï£ºÎ¨∏ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', {
        position: 'top-center',
        duration: 3000
      });
    }
  };

  const handleSelectAll = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.checked) {
      setSelectedOrders(orders.map(o => o.id));
    } else {
      setSelectedOrders([]);
    }
  };

  const handleSelectOrder = (orderId: number) => {
    if (selectedOrders.includes(orderId)) {
      setSelectedOrders(selectedOrders.filter(id => id !== orderId));
    } else {
      setSelectedOrders([...selectedOrders, orderId]);
    }
  };

  const filteredOrders = orders.filter(order => {
    // ÏÉÅÌÉú ÌïÑÌÑ∞
    const matchesStatus = filterStatus === 'all' || order.status === filterStatus;

    // ÎÇ†Ïßú ÌïÑÌÑ∞ (ÌïúÍµ≠ ÏãúÍ∞Ñ Í∏∞Ï§Ä)
    let matchesDate = true;
    if (startDate || endDate) {
      // UTC ÏãúÍ∞ÑÏùÑ ÌïúÍµ≠ ÏãúÍ∞Ñ(UTC+9)ÏúºÎ°ú Î≥ÄÌôò
      const orderDate = new Date(order.date);
      const koreaOrderDate = new Date(orderDate.getTime() + (9 * 60 * 60 * 1000));

      // ÌïúÍµ≠ ÏãúÍ∞Ñ Í∏∞Ï§Ä ÎÇ†ÏßúÎßå Ï∂îÏ∂ú (ÏãúÍ∞Ñ Ï†úÍ±∞)
      const orderDateOnly = new Date(
        koreaOrderDate.getUTCFullYear(),
        koreaOrderDate.getUTCMonth(),
        koreaOrderDate.getUTCDate()
      );

      if (startDate) {
        const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
        if (orderDateOnly < startDateOnly) {
          matchesDate = false;
        }
      }
      if (endDate) {
        const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
        if (orderDateOnly > endDateOnly) {
          matchesDate = false;
        }
      }
    }

    // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞ (Î™®Îì† Ïª¨Îüº ÎåÄÏÉÅ)
    let matchesSearch = true;
    if (searchTerm && searchTerm.trim()) {
      // ÎØ∏ÏôÑÏÑ± ÏûêÏùå/Î™®Ïùå Ï†úÍ±∞ (ÏôÑÏÑ±Îêú Í∏ÄÏûêÎßå ÎÇ®ÍπÄ)
      const cleanedSearchTerm = searchTerm.replace(/[„Ñ±-„Öé„Öè-„Ö£]/g, '');

      // ÏôÑÏÑ±Îêú Í∏ÄÏûêÍ∞Ä ÏóÜÏúºÎ©¥ ÌïÑÌÑ∞ÎßÅ ÌïòÏßÄ ÏïäÏùå
      if (!cleanedSearchTerm.trim()) {
        return true;
      }

      const searchLower = cleanedSearchTerm.toLowerCase();
      matchesSearch = Object.values(order).some(value =>
        String(value || '').toLowerCase().includes(searchLower)
      );
    }

    return matchesStatus && matchesDate && matchesSearch;
  });

  console.log('üîç ÌïÑÌÑ∞ ÏÉÅÌÉú:', { filterStatus, startDate, endDate, searchTerm });
  console.log('üìä Ï†ÑÏ≤¥ Ï£ºÎ¨∏:', orders.length, '/ ÌïÑÌÑ∞Îêú Ï£ºÎ¨∏:', filteredOrders.length);

  return (
    <div className="platform-orders-page" style={{ minHeight: '100vh', background: 'var(--color-background)' }}>
      {/* Toast Ïª®ÌÖåÏù¥ÎÑà */}
      <Toaster
        position="top-center"
        toastOptions={{
          duration: 3000,
          style: {
            minWidth: '300px',
            maxWidth: '500px',
            padding: '16px 24px',
            fontSize: '15px',
            fontWeight: '500',
            boxShadow: '0 10px 40px rgba(0, 0, 0, 0.2)',
          },
          success: {
            iconTheme: {
              primary: '#10b981',
              secondary: '#fff',
            },
          },
          error: {
            iconTheme: {
              primary: '#ef4444',
              secondary: '#fff',
            },
          },
        }}
      />
      {/* Î∞úÏ£ºÍ¥ÄÎ¶¨ Ï†ÑÏö© Ìó§Îçî */}
      <div style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '70px',
        background: 'var(--color-background-secondary)',
        borderBottom: '1px solid var(--color-border)',
        zIndex: 1100,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: isMobile ? '0 16px' : '0 24px'
      }}>
        {/* ÏôºÏ™Ω: ÌñÑÎ≤ÑÍ±∞ Î©îÎâ¥(Î™®Î∞îÏùº) + ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº & Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥ */}
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          {/* ÌñÑÎ≤ÑÍ±∞ Î©îÎâ¥ Î≤ÑÌäº (Î™®Î∞îÏùºÎßå) */}
          {isMobile && (
            <button
              onClick={() => setSidebarOpen(!sidebarOpen)}
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                width: '40px',
                height: '40px',
                background: 'var(--color-surface)',
                border: '1px solid var(--color-border)',
                borderRadius: '8px',
                cursor: 'pointer',
                transition: 'background 0.2s'
              }}
              onMouseEnter={(e) => e.currentTarget.style.background = 'var(--color-surface-hover)'}
              onMouseLeave={(e) => e.currentTarget.style.background = 'var(--color-surface)'}
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
              </svg>
            </button>
          )}

          {/* ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº */}
          <button
            onClick={() => { router.push('/'); }}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              padding: '8px 16px',
              background: 'var(--color-surface)',
              border: '1px solid var(--color-border)',
              borderRadius: '8px',
              fontSize: '14px',
              color: 'var(--color-text)',
              fontWeight: '500',
              cursor: 'pointer',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.background = 'var(--color-surface-hover)';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.background = 'var(--color-surface)';
            }}
          >
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
              <polyline points="16 17 21 12 16 7"></polyline>
              <line x1="21" y1="12" x2="9" y2="12"></line>
            </svg>
            ÎÇòÍ∞ÄÍ∏∞
          </button>

          {/* Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥ */}
          <div style={{
            fontSize: '14px',
            color: 'var(--color-text)',
            fontWeight: '500'
          }}>
            {userEmail || 'Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥ ÏóÜÏùå'}
          </div>
        </div>

        {/* Ïò§Î•∏Ï™Ω: Îã§ÌÅ¨Î™®Îìú ÌÜ†Í∏Ä */}
        <ThemeToggle />
      </div>

      {/* Overlay (Î™®Î∞îÏùºÏóêÏÑú ÏÇ¨Ïù¥ÎìúÎ∞î Ïó¥Î¶¥ Îïå) */}
      {isMobile && sidebarOpen && (
        <div
          onClick={() => setSidebarOpen(false)}
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            background: 'rgba(0, 0, 0, 0.5)',
            zIndex: 1050,
            transition: 'opacity 0.3s'
          }}
        />
      )}

      {/* Sidebar */}
      <div style={{
        position: 'fixed',
        top: '70px',
        left: isMobile ? (sidebarOpen ? 0 : '-250px') : 0,
        width: isMobile ? '250px' : '175px',
        height: 'calc(100vh - 70px)',
        background: 'var(--color-background-secondary)',
        borderRight: '1px solid var(--color-border)',
        zIndex: 1100,
        transition: 'left 0.3s ease',
        overflowY: 'auto'
      }}>
        <div style={{
          paddingTop: '16px',
          paddingLeft: isMobile ? '6px' : '12px',
          paddingRight: isMobile ? '6px' : '12px'
        }}>
          {/* ÎåÄÏãúÎ≥¥Îìú ÌÉ≠ */}
          <button
            onClick={() => handleTabChange('ÎåÄÏãúÎ≥¥Îìú')}
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: isMobile ? '10px 8px' : '10px 16px',
              margin: isMobile ? '4px 6px' : '2px 8px',
              background: activeTab === 'ÎåÄÏãúÎ≥¥Îìú' ? 'var(--color-surface-hover)' : 'transparent',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: isMobile ? '12px' : '14px',
              fontWeight: activeTab === 'ÎåÄÏãúÎ≥¥Îìú' ? '600' : '400',
              color: 'var(--color-text)',
              textAlign: 'left',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => {
              if (activeTab !== 'ÎåÄÏãúÎ≥¥Îìú') {
                e.currentTarget.style.background = 'var(--color-surface-hover)';
              }
            }}
            onMouseLeave={(e) => {
              if (activeTab !== 'ÎåÄÏãúÎ≥¥Îìú') {
                e.currentTarget.style.background = 'transparent';
              }
            }}
          >
            <svg width={isMobile ? '16' : '20'} height={isMobile ? '16' : '20'} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
              <polyline points="9 22 9 12 15 12 15 22"></polyline>
            </svg>
            ÎåÄÏãúÎ≥¥Îìú
          </button>

          {/* Î∞úÏ£ºÏÑúÎì±Î°ù ÌÉ≠ */}
          <button
            onClick={() => handleTabChange('Î∞úÏ£ºÏÑúÎì±Î°ù')}
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: isMobile ? '10px 8px' : '10px 16px',
              margin: isMobile ? '4px 6px' : '2px 8px',
              background: activeTab === 'Î∞úÏ£ºÏÑúÎì±Î°ù' ? 'var(--color-surface-hover)' : 'transparent',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: isMobile ? '12px' : '14px',
              fontWeight: activeTab === 'Î∞úÏ£ºÏÑúÎì±Î°ù' ? '600' : '400',
              color: 'var(--color-text)',
              textAlign: 'left',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => {
              if (activeTab !== 'Î∞úÏ£ºÏÑúÎì±Î°ù') {
                e.currentTarget.style.background = 'var(--color-surface-hover)';
              }
            }}
            onMouseLeave={(e) => {
              if (activeTab !== 'Î∞úÏ£ºÏÑúÎì±Î°ù') {
                e.currentTarget.style.background = 'transparent';
              }
            }}
          >
            <svg width={isMobile ? '16' : '20'} height={isMobile ? '16' : '20'} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="16" y1="13" x2="8" y2="13"></line>
              <line x1="16" y1="17" x2="8" y2="17"></line>
              <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
            Î∞úÏ£ºÏÑúÎì±Î°ù
          </button>

          {/* Î™®Î∞îÏùºÎì±Î°ù ÌÉ≠ */}
          <button
            onClick={() => handleTabChange('Î™®Î∞îÏùºÎì±Î°ù')}
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: isMobile ? '10px 8px' : '10px 16px',
              margin: isMobile ? '4px 6px' : '2px 8px',
              background: activeTab === 'Î™®Î∞îÏùºÎì±Î°ù' ? 'var(--color-surface-hover)' : 'transparent',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: isMobile ? '12px' : '14px',
              fontWeight: activeTab === 'Î™®Î∞îÏùºÎì±Î°ù' ? '600' : '400',
              color: 'var(--color-text)',
              textAlign: 'left',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => {
              if (activeTab !== 'Î™®Î∞îÏùºÎì±Î°ù') {
                e.currentTarget.style.background = 'var(--color-surface-hover)';
              }
            }}
            onMouseLeave={(e) => {
              if (activeTab !== 'Î™®Î∞îÏùºÎì±Î°ù') {
                e.currentTarget.style.background = 'transparent';
              }
            }}
          >
            <svg width={isMobile ? '16' : '20'} height={isMobile ? '16' : '20'} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
              <line x1="12" y1="18" x2="12.01" y2="18"></line>
            </svg>
            Î™®Î∞îÏùºÎì±Î°ù
          </button>

          {/* Ï†ïÏÇ∞Í¥ÄÎ¶¨ ÌÉ≠ */}
          <button
            onClick={() => handleTabChange('Ï†ïÏÇ∞Í¥ÄÎ¶¨')}
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: isMobile ? '10px 8px' : '10px 16px',
              margin: isMobile ? '4px 6px' : '2px 8px',
              background: activeTab === 'Ï†ïÏÇ∞Í¥ÄÎ¶¨' ? 'var(--color-surface-hover)' : 'transparent',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: isMobile ? '12px' : '14px',
              fontWeight: activeTab === 'Ï†ïÏÇ∞Í¥ÄÎ¶¨' ? '600' : '400',
              color: 'var(--color-text)',
              textAlign: 'left',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => {
              if (activeTab !== 'Ï†ïÏÇ∞Í¥ÄÎ¶¨') {
                e.currentTarget.style.background = 'var(--color-surface-hover)';
              }
            }}
            onMouseLeave={(e) => {
              if (activeTab !== 'Ï†ïÏÇ∞Í¥ÄÎ¶¨') {
                e.currentTarget.style.background = 'transparent';
              }
            }}
          >
            <svg width={isMobile ? '16' : '20'} height={isMobile ? '16' : '20'} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <rect x="3" y="3" width="7" height="7"></rect>
              <rect x="14" y="3" width="7" height="7"></rect>
              <rect x="14" y="14" width="7" height="7"></rect>
              <rect x="3" y="14" width="7" height="7"></rect>
            </svg>
            Ï†ïÏÇ∞Í¥ÄÎ¶¨
          </button>

          {/* ÏòµÏÖòÎ™ÖÎß§Ìïë ÌÉ≠ */}
          <button
            onClick={() => handleTabChange('ÏòµÏÖòÎ™ÖÎß§Ìïë')}
            style={{
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: isMobile ? '10px 8px' : '10px 16px',
              margin: isMobile ? '4px 6px' : '2px 8px',
              background: activeTab === 'ÏòµÏÖòÎ™ÖÎß§Ìïë' ? 'var(--color-surface-hover)' : 'transparent',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              fontSize: isMobile ? '12px' : '14px',
              fontWeight: activeTab === 'ÏòµÏÖòÎ™ÖÎß§Ìïë' ? '600' : '400',
              color: 'var(--color-text)',
              textAlign: 'left',
              transition: 'background 0.2s'
            }}
            onMouseEnter={(e) => {
              if (activeTab !== 'ÏòµÏÖòÎ™ÖÎß§Ìïë') {
                e.currentTarget.style.background = 'var(--color-surface-hover)';
              }
            }}
            onMouseLeave={(e) => {
              if (activeTab !== 'ÏòµÏÖòÎ™ÖÎß§Ìïë') {
                e.currentTarget.style.background = 'transparent';
              }
            }}
          >
            <svg width={isMobile ? '16' : '20'} height={isMobile ? '16' : '20'} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="9" y1="15" x2="15" y2="15"></line>
              <line x1="12" y1="12" x2="12" y2="18"></line>
            </svg>
            ÏòµÏÖòÎ™ÖÎß§Ìïë
          </button>
        </div>
      </div>

      {/* Main content area */}
      <div style={{
        marginLeft: isMobile ? '0' : '175px',
        padding: isMobile ? '16px' : '24px',
        paddingTop: '90px',
        background: 'var(--color-background)',
        minHeight: '100vh',
        overflowY: 'auto'
      }}>
        {/* Tab Content */}
        {activeTab === 'ÎåÄÏãúÎ≥¥Îìú' && (
          <div style={{
            maxWidth: '1440px',
            margin: '0 auto'
          }}>
            <DashboardTab
              isMobile={isMobile}
              orders={orders}
              statusConfig={statusConfig}
            />
          </div>
        )}
        {activeTab === 'Î∞úÏ£ºÏÑúÎì±Î°ù' && (
          <div style={{
            width: '100%'
          }}>
            <OrderRegistrationTab
              isMobile={isMobile}
              orders={orders}
              statsData={statsData}
              statusConfig={statusConfig}
              filterStatus={filterStatus}
              setFilterStatus={setFilterStatus}
              searchTerm={searchTerm}
              setSearchTerm={setSearchTerm}
              selectedOrders={selectedOrders}
              setSelectedOrders={setSelectedOrders}
              setShowUploadModal={setShowUploadModal}
              filteredOrders={filteredOrders}
              handleSelectAll={handleSelectAll}
              handleSelectOrder={handleSelectOrder}
              setSelectedOrder={setSelectedOrder}
              setShowDetailModal={setShowDetailModal}
              startDate={startDate}
              setStartDate={setStartDate}
              endDate={endDate}
              setEndDate={setEndDate}
              onRefresh={fetchOrders}
              userId={userId}
              userEmail={userEmail}
            />
          </div>
        )}
        {activeTab === 'Î™®Î∞îÏùºÎì±Î°ù' && (
          <MobileRegistrationTab
            isMobile={isMobile}
            onRefresh={fetchOrders}
            userEmail={userEmail}
          />
        )}
        {activeTab === 'Ï†ïÏÇ∞Í¥ÄÎ¶¨' && (
          <div style={{
            maxWidth: '1440px',
            margin: '0 auto'
          }}>
            <SettlementTab
              isMobile={isMobile}
              orders={orders}
            />
          </div>
        )}
        {activeTab === 'ÏòµÏÖòÎ™ÖÎß§Ìïë' && (
          <div style={{
            maxWidth: '1440px',
            margin: '0 auto'
          }}>
            <OptionMappingTab
              isMobile={isMobile}
            />
          </div>
        )}

        {/* Î™®Îã¨Îì§ */}
        <UploadModal
          showUploadModal={showUploadModal}
          setShowUploadModal={setShowUploadModal}
          dragActive={dragActive}
          handleDrag={handleDrag}
          handleDrop={handleDrop}
          fileInputRef={fileInputRef}
          handleFiles={handleFiles}
        />


        <OrderDetailModal
          showDetailModal={showDetailModal}
          setShowDetailModal={setShowDetailModal}
          selectedOrder={selectedOrder}
          statusConfig={statusConfig}
        />

        <ValidationErrorModal
          show={showValidationModal}
          onClose={() => setShowValidationModal(false)}
          errors={validationErrors}
        />

        <MappingResultModal
          show={showMappingResultModal}
          onClose={() => {
            setShowMappingResultModal(false);
            setShowUploadModal(true);
          }}
          onContinue={() => {
            setShowMappingResultModal(false);
            // Îß§Ìïë ÌõÑÏóêÎèÑ Îß§Ïπ≠ Ïã§Ìå®Ìïú ÏòµÏÖòÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            const unmatchedOrders = uploadedOrders.filter(order => {
              const optionName = order.optionName || '';
              const key = optionName.trim().toLowerCase();
              return !optionProductsMap.has(key);
            });

            if (unmatchedOrders.length > 0) {
              // 3Îã®Í≥Ñ: Îß§Ïπ≠ Ïã§Ìå®Ìïú ÏòµÏÖòÏù¥ ÏûàÏúºÎ©¥ Í≤ÄÏ¶ù Î™®Îã¨ ÌëúÏãú
              setShowOptionValidationModal(true);
            } else {
              // 4Îã®Í≥Ñ: Î™®Îëê Îß§Ïπ≠ ÏÑ±Í≥µÏù¥Î©¥ Î∞îÎ°ú Ï†ÄÏû•
              handleSaveValidatedOrders(uploadedOrders);
            }
          }}
          results={mappingResults}
          totalOrders={mappingStats.total}
          mappedOrders={mappingStats.mapped}
        />

        <OptionValidationModal
          show={showOptionValidationModal}
          onClose={() => setShowOptionValidationModal(false)}
          orders={uploadedOrders}
          onSave={handleSaveValidatedOrders}
          optionProducts={optionProductsMap}
        />
      </div>
    </div>
  );
}
